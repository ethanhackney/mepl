slab_base
=========
struct ptr *(*sb_get)(struct pool *pool)
void       (*sb_put)(struct pool *pool, struct ptr *ptr)

slab<T>
=======
struct slab_base s_base
struct ring<T>   s_ring
struct list      s_nodes
size_t           s_pool_sz
size_t           s_ring_sz

slab_node<T>
============
struct bitset<T> sn_set
struct list      sn_nodes
size_t           sn_count
T                *sn_pool

the slab tab can be a perfect hash table because there are a fixed number
of slabs (one for each type)

O(1) to find a slab{}
O(1) to allocate from a slab{}
O(1) to reach slab_node{} from ptr{}
O(1) to remove slab_node{} from list{}

hash_map<str,slab_base*> slab_tab {
        { "AST_STR", &ast_str_slab.ss_slab },
        { "AST_VAR_DEF", &ast_var_def_slab.vds_slab },
};

slab_node{
        .arr   = [ ][ ][ ][ ][ ]    # fixed size array
        .set   = 000000000000000000 # bitset of (len(.arr) >> 64) words
        .count = 5                  # count of available nodes
        .nodes = { }<-+             # circular doubly linked list of all slab nodes
}                 ^   |             # the same list node is used for slab.nodes
                  +---+             # and slab.empty because they are mutually
                                    # exclusive

slab{
                  
        .nodes = { }<-- # circular doubly linked list of all non-empty slab nodes
                  ^   |
                  +---+
        .empty = { }<-+ # circular doubly linked list of all empty slab nodes
                  ^   |
                  +---+
        .ring  = [ ][ ][ ][ ] # fixed size ring buffer of pointers to freed nodes
                  |  |  |  |
                  |  |  |  +--------> { free slab node kept for future use }
                  |  |  +-----------> { free slab node kept for future use }
                  |  +--------------> { free slab node kept for future use }
                  +-----------------> { free slab node kept for future use }
}

slab_tab{
        # hash table mapping type names to slabs that provide that type
}

the hash table based thing is dumb, it doesnt actually help with decoupling
and only slows things down

slabhash = {
        ["AST_VAR_DEF"] ==> {                 |  |  |  |
                                .s_ring[]  = [ ][ ][ ][ ]
                                .s_nodes[] = { circular list of bitset + array },
                            }
}
                                     +------------------> { free cached slab_node }
                                     |  +---------------> { free cached slab_node }
                                     |  |  +------------> { free cached slab_node }
["AST_VAR_DEF"]=====>{               |  |  |
                        .s_ring[] = [ ][ ][ ]

                                     +------{ slab_node }-------{ slab_node }--------+
                                     |                                               
                        .s_nodes  = { }                                              |
                                     |                                               |
                                     +-----------------------------------------------+
